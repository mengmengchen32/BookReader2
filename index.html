<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Flashcards">
<meta name="theme-color" content="#1a1a2e">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üÉè</text></svg>">
<title>‰Ωë‰ΩëÁöÑËÆ§Â≠óÂç°</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@600;700;800&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --pink: #f472b6;
    --pink-light: #f9a8d4;
    --pink-hot: #ec4899;
    --yellow: #fbbf24;
    --orange: #fb923c;
    --purple: #a78bfa;
    --blue: #60a5fa;
    --green: #4ade80;
    --bg-warm: #1e1026;
    --bg-card: #2e1f3d;
    --radius: 20px;
  }

  body {
    font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
    background: var(--bg-warm);
    color: #fff;
    height: 100dvh;
    overflow: hidden;
    touch-action: manipulation;
  }

  /* ===== CAMERA ===== */
  #camera-container {
    position: relative;
    width: 100%;
    height: 100dvh;
  }

  #video {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  #canvas { display: none; }

  #camera-frame {
    position: absolute;
    inset: 12px;
    border: 3px dashed rgba(255,255,255,0.25);
    border-radius: 24px;
    pointer-events: none;
    z-index: 2;
  }

  #top-bar {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding: 12px 16px 16px;
    background: linear-gradient(to bottom, rgba(30,16,38,0.9) 0%, transparent 100%);
    z-index: 10;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  #mascot {
    font-size: 36px;
    animation: wiggle 2s ease-in-out infinite;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
  }

  @keyframes wiggle {
    0%, 100% { transform: rotate(-5deg); }
    50% { transform: rotate(5deg); }
  }

  #app-title {
    display: flex;
    flex-direction: column;
    line-height: 1.1;
  }

  #app-title .cn {
    font-size: 20px;
    font-weight: 800;
    background: linear-gradient(135deg, var(--pink), var(--yellow));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  #app-title .en {
    font-size: 11px;
    font-weight: 600;
    color: rgba(255,255,255,0.6);
  }

  #capture-btn {
    position: absolute;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: 4px solid white;
    background: rgba(244, 114, 182, 0.8);
    font-size: 36px;
    cursor: pointer;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    transition: transform 0.15s;
  }

  #capture-btn:active {
    transform: translateX(-50%) scale(0.9);
  }

  #library-btn {
    position: absolute;
    bottom: 52px;
    right: 24px;
    width: 56px;
    height: 56px;
    border-radius: 50%;
    border: none;
    background: var(--bg-card);
    font-size: 28px;
    cursor: pointer;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 12px rgba(0,0,0,0.3);
  }

  #progress-btn {
    position: absolute;
    bottom: 52px;
    left: 24px;
    width: 56px;
    height: 56px;
    border-radius: 50%;
    border: none;
    background: var(--bg-card);
    font-size: 28px;
    cursor: pointer;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 12px rgba(0,0,0,0.3);
  }

  #settings-btn {
    position: absolute;
    top: 16px;
    right: 16px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none;
    background: rgba(255,255,255,0.15);
    font-size: 20px;
    cursor: pointer;
    z-index: 11;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  #hint {
    position: absolute;
    bottom: 130px;
    left: 0;
    right: 0;
    text-align: center;
    font-size: 16px;
    font-weight: 700;
    color: rgba(255,255,255,0.7);
    z-index: 10;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
  }

  #status {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(30,16,38,0.95);
    padding: 16px 28px;
    border-radius: 16px;
    font-size: 16px;
    font-weight: 700;
    display: none;
    align-items: center;
    gap: 12px;
    z-index: 20;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
  }

  #status.visible { display: flex; }

  .spinner {
    width: 24px;
    height: 24px;
    border: 3px solid rgba(255,255,255,0.2);
    border-top-color: var(--pink);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  #flash {
    position: absolute;
    inset: 0;
    background: white;
    opacity: 0;
    pointer-events: none;
    z-index: 30;
    transition: opacity 0.15s;
  }

  #flash.active { opacity: 0.8; }

  .deck-count {
    position: absolute;
    top: -4px;
    right: -4px;
    background: var(--pink-hot);
    color: white;
    font-size: 12px;
    font-weight: 800;
    min-width: 22px;
    height: 22px;
    border-radius: 11px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 6px;
  }

  /* ===== SCREEN OVERLAYS ===== */
  .screen {
    position: fixed;
    inset: 0;
    background: var(--bg-warm);
    z-index: 50;
    display: none;
    flex-direction: column;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  .screen.visible { display: flex; }

  .screen-header {
    display: flex;
    align-items: center;
    padding: 12px 16px;
    gap: 12px;
    background: rgba(30,16,38,0.95);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    position: sticky;
    top: 0;
    z-index: 5;
  }

  .back-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none;
    background: rgba(255,255,255,0.1);
    color: white;
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }

  .screen-title {
    font-size: 18px;
    font-weight: 800;
    flex: 1;
  }

  /* ===== API KEY OVERLAY ===== */
  #api-key-overlay {
    position: fixed;
    inset: 0;
    background: var(--bg-warm);
    z-index: 100;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 24px;
    gap: 16px;
    text-align: center;
  }

  #api-key-overlay.hidden { display: none; }
  #api-key-overlay .emoji { font-size: 64px; }

  #api-key-overlay h2 {
    font-size: 24px;
    background: linear-gradient(135deg, var(--pink), var(--yellow));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  #api-key-overlay input {
    width: 100%;
    max-width: 320px;
    padding: 14px 16px;
    border-radius: 12px;
    border: 2px solid rgba(255,255,255,0.1);
    background: var(--bg-card);
    color: white;
    font-size: 16px;
    font-family: inherit;
    outline: none;
  }

  #api-key-overlay input:focus { border-color: var(--pink); }

  #api-key-overlay button {
    padding: 14px 40px;
    border-radius: 12px;
    border: none;
    background: linear-gradient(135deg, var(--pink-hot), var(--purple));
    color: white;
    font-size: 18px;
    font-weight: 800;
    cursor: pointer;
    font-family: inherit;
  }

  /* ===== TEXT REVIEW ===== */
  .review-image {
    width: 100%;
    max-height: 35vh;
    object-fit: contain;
    background: #000;
  }

  .review-body {
    padding: 20px 16px;
    flex: 1;
  }

  .review-stats {
    background: linear-gradient(135deg, var(--pink), var(--purple));
    padding: 12px 16px;
    border-radius: 12px;
    font-size: 18px;
    font-weight: 800;
    text-align: center;
    margin-bottom: 16px;
  }

  .review-sentences {
    background: var(--bg-card);
    border-radius: 16px;
    padding: 16px;
    margin-bottom: 20px;
    font-size: 18px;
    line-height: 1.8;
  }

  .review-sentences p { margin-bottom: 8px; }
  .review-sentences p:last-child { margin-bottom: 0; }

  .sight-word {
    background: rgba(244, 114, 182, 0.3);
    color: var(--pink-light);
    padding: 2px 6px;
    border-radius: 6px;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.2s;
  }

  .sight-word.excluded {
    background: rgba(255,255,255,0.05);
    color: rgba(255,255,255,0.3);
    text-decoration: line-through;
  }

  .learned-word {
    background: rgba(74, 222, 128, 0.3);
    color: var(--green);
    padding: 2px 6px;
    border-radius: 6px;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.2s;
  }

  .learned-word.excluded {
    background: rgba(255,255,255,0.05);
    color: rgba(255,255,255,0.3);
    text-decoration: line-through;
  }

  .make-flashcards-btn {
    width: 100%;
    padding: 18px;
    border-radius: 16px;
    border: none;
    background: linear-gradient(135deg, var(--pink-hot), var(--orange));
    color: white;
    font-size: 20px;
    font-weight: 800;
    cursor: pointer;
    font-family: inherit;
    box-shadow: 0 4px 20px rgba(236, 72, 153, 0.4);
  }

  .make-flashcards-btn:active { transform: scale(0.97); }

  .no-words-msg {
    text-align: center;
    color: rgba(255,255,255,0.5);
    font-size: 16px;
    padding: 20px;
  }

  /* ===== FLASHCARD VIEW ===== */
  #flashcard-view { overflow: hidden; }

  .card-counter {
    font-size: 16px;
    font-weight: 700;
    color: rgba(255,255,255,0.6);
  }

  .flashcard-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    gap: 20px;
    overflow: hidden;
  }

  /* 3D Flashcard */
  .flashcard {
    perspective: 1200px;
    width: calc(100vw - 48px);
    max-width: 340px;
    height: 420px;
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
  }

  .flashcard-inner {
    position: relative;
    width: 100%;
    height: 100%;
    transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    transform-style: preserve-3d;
  }

  .flashcard.flipped .flashcard-inner {
    transform: rotateY(180deg);
  }

  .flashcard-front, .flashcard-back {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
    border-radius: 24px;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow: hidden;
  }

  .flashcard-front {
    background: linear-gradient(160deg, #3b2450, #2e1f3d);
    border: 2px solid rgba(255,255,255,0.1);
    justify-content: center;
    gap: 20px;
    padding: 24px;
  }

  .flashcard-back {
    background: linear-gradient(160deg, #2a1835, #1e1026);
    border: 2px solid rgba(255,255,255,0.1);
    transform: rotateY(180deg);
    padding: 0;
  }

  .card-level-badge {
    padding: 6px 14px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .level-pre-primer { background: rgba(244,114,182,0.2); color: var(--pink-light); }
  .level-primer { background: rgba(251,191,36,0.2); color: var(--yellow); }
  .level-first-grade { background: rgba(96,165,250,0.2); color: var(--blue); }
  .level-second-grade { background: rgba(167,139,250,0.2); color: var(--purple); }
  .level-third-grade { background: rgba(74,222,128,0.2); color: var(--green); }

  .card-word {
    font-size: 56px;
    font-weight: 800;
    text-align: center;
    text-shadow: 0 2px 8px rgba(0,0,0,0.3);
  }

  .card-speak-btn {
    width: 56px;
    height: 56px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1);
    font-size: 28px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    z-index: 5;
    pointer-events: auto;
  }

  .card-speak-btn:active { background: rgba(255,255,255,0.2); }
  .card-speak-btn.loading { opacity: 0.5; }

  .card-back-sentence {
    padding: 24px 20px;
    font-size: 20px;
    line-height: 1.6;
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
  }

  .card-back-sentence .highlight {
    background: rgba(244,114,182,0.3);
    color: var(--pink-light);
    padding: 2px 6px;
    border-radius: 6px;
    font-weight: 800;
  }

  .card-back-image {
    width: 100%;
    height: 180px;
    object-fit: cover;
    border-radius: 0 0 22px 22px;
  }

  .know-btn {
    padding: 16px 40px;
    border-radius: 16px;
    border: none;
    background: linear-gradient(135deg, var(--green), #22c55e);
    color: white;
    font-size: 18px;
    font-weight: 800;
    cursor: pointer;
    font-family: inherit;
    box-shadow: 0 4px 16px rgba(74,222,128,0.3);
    transition: all 0.2s;
  }

  .know-btn:active { transform: scale(0.95); }

  .know-btn.known {
    background: rgba(74,222,128,0.2);
    color: var(--green);
    box-shadow: none;
  }

  .card-dots {
    display: flex;
    gap: 6px;
    justify-content: center;
    padding: 12px 0 24px;
    flex-wrap: wrap;
    max-width: 90vw;
    margin: 0 auto;
  }

  .card-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: rgba(255,255,255,0.2);
    transition: all 0.3s;
  }

  .card-dot.active {
    background: var(--pink);
    width: 24px;
    border-radius: 4px;
  }

  .card-dot.learned { background: var(--green); }

  /* ===== DECK LIBRARY ===== */
  .library-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 12px;
    padding: 16px;
  }

  .deck-card {
    background: var(--bg-card);
    border-radius: 16px;
    overflow: hidden;
    cursor: pointer;
    position: relative;
    transition: transform 0.15s;
  }

  .deck-card:active { transform: scale(0.97); }

  .deck-card img {
    width: 100%;
    height: 120px;
    object-fit: cover;
  }

  .deck-info {
    padding: 10px 12px;
  }

  .deck-name {
    font-size: 13px;
    font-weight: 700;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .deck-meta {
    font-size: 11px;
    color: rgba(255,255,255,0.5);
    margin-top: 4px;
    display: flex;
    gap: 8px;
  }

  .deck-meta .learned-count { color: var(--green); }

  .delete-deck-btn {
    position: absolute;
    top: 6px;
    right: 6px;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: none;
    background: rgba(0,0,0,0.6);
    color: white;
    font-size: 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .library-empty {
    grid-column: 1 / -1;
    text-align: center;
    padding: 60px 20px;
    color: rgba(255,255,255,0.4);
    font-size: 16px;
  }

  .library-empty .empty-icon {
    font-size: 48px;
    display: block;
    margin-bottom: 12px;
  }

  /* ===== PROGRESS PANEL ===== */
  .progress-content { padding: 16px; }

  .progress-overall {
    text-align: center;
    padding: 24px;
    background: linear-gradient(135deg, rgba(244,114,182,0.15), rgba(167,139,250,0.15));
    border-radius: 20px;
    margin-bottom: 20px;
  }

  .progress-big-number {
    font-size: 48px;
    font-weight: 800;
    background: linear-gradient(135deg, var(--pink), var(--yellow));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .progress-subtitle {
    font-size: 14px;
    color: rgba(255,255,255,0.6);
    margin-top: 4px;
  }

  .level-section { margin-bottom: 16px; }

  .level-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }

  .level-name { font-size: 15px; font-weight: 700; }
  .level-count { font-size: 13px; color: rgba(255,255,255,0.5); }

  .progress-bar {
    height: 12px;
    background: rgba(255,255,255,0.1);
    border-radius: 6px;
    overflow: hidden;
    margin-bottom: 8px;
  }

  .progress-fill {
    height: 100%;
    border-radius: 6px;
    transition: width 0.5s ease;
  }

  .level-words {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .word-chip {
    padding: 4px 10px;
    border-radius: 8px;
    font-size: 12px;
    font-weight: 700;
    background: rgba(255,255,255,0.1);
    color: rgba(255,255,255,0.4);
    cursor: pointer;
  }

  .word-chip.learned {
    background: rgba(74,222,128,0.2);
    color: var(--green);
  }

  /* ===== SETTINGS ===== */
  .settings-content {
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .setting-group {
    background: var(--bg-card);
    border-radius: 16px;
    padding: 16px;
  }

  .setting-group label {
    display: block;
    font-size: 14px;
    font-weight: 700;
    color: rgba(255,255,255,0.6);
    margin-bottom: 8px;
  }

  .setting-group input, .setting-group select {
    width: 100%;
    padding: 12px;
    border-radius: 10px;
    border: 2px solid rgba(255,255,255,0.1);
    background: rgba(0,0,0,0.2);
    color: white;
    font-size: 16px;
    font-family: inherit;
    outline: none;
  }

  .setting-group input:focus, .setting-group select:focus {
    border-color: var(--pink);
  }

  .setting-group select option { background: var(--bg-card); }

  .save-settings-btn {
    padding: 16px;
    border-radius: 16px;
    border: none;
    background: linear-gradient(135deg, var(--pink-hot), var(--purple));
    color: white;
    font-size: 18px;
    font-weight: 800;
    cursor: pointer;
    font-family: inherit;
  }

  /* ===== CELEBRATION ===== */
  #celebration {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 200;
  }

  .confetti {
    position: absolute;
    width: 10px;
    height: 10px;
    border-radius: 2px;
    animation: confetti-fall 1.2s ease-out forwards;
  }

  @keyframes confetti-fall {
    0% { transform: translateY(0) rotate(0deg) scale(1); opacity: 1; }
    100% { transform: translateY(100vh) rotate(720deg) scale(0); opacity: 0; }
  }

  /* ===== RESPONSIVE ===== */
  @media (min-width: 768px) {
    .flashcard { max-width: 380px; height: 480px; }
    .library-grid { grid-template-columns: repeat(3, 1fr); }
  }
</style>
</head>
<body>

<!-- ===== CAMERA SCREEN ===== -->
<div id="camera-container">
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>
  <div id="flash"></div>
  <div id="camera-frame"></div>

  <div id="top-bar">
    <div id="mascot">üÉè</div>
    <div id="app-title">
      <span class="cn">‰Ωë‰ΩëÁöÑËÆ§Â≠óÂç°</span>
      <span class="en">Hunter's Flashcards</span>
    </div>
  </div>

  <button id="settings-btn">‚öôÔ∏è</button>
  <div id="hint">Point at a book page, then tap!</div>
  <button id="progress-btn">‚≠ê</button>
  <button id="capture-btn">üì∏</button>
  <button id="library-btn">üìö</button>
  <div id="status"></div>
</div>

<!-- ===== API KEY OVERLAY ===== -->
<div id="api-key-overlay">
  <div class="emoji">üÉè</div>
  <h2>‰Ωë‰ΩëÁöÑËÆ§Â≠óÂç°</h2>
  <p style="color: rgba(255,255,255,0.6); font-size: 14px;">
    Enter your OpenAI API key to get started
  </p>
  <input type="password" id="initial-api-key" placeholder="sk-...">
  <button id="submit-api-key">Let's Go!</button>
</div>

<!-- ===== TEXT REVIEW ===== -->
<div id="text-review" class="screen">
  <div class="screen-header">
    <button class="back-btn" id="close-review">‚úï</button>
    <span class="screen-title">Text Found</span>
  </div>
  <img id="review-image" class="review-image" alt="Captured page">
  <div class="review-body">
    <div id="review-stats" class="review-stats"></div>
    <div id="review-sentences" class="review-sentences"></div>
    <button id="make-flashcards-btn" class="make-flashcards-btn">üÉè Make Flashcards!</button>
  </div>
</div>

<!-- ===== FLASHCARD VIEW ===== -->
<div id="flashcard-view" class="screen">
  <div class="screen-header">
    <button class="back-btn" id="close-flashcards">‚úï</button>
    <span class="screen-title">Flashcards</span>
    <span id="card-counter" class="card-counter"></span>
  </div>
  <div class="flashcard-area" id="flashcard-area">
    <div class="flashcard" id="flashcard">
      <div class="flashcard-inner" id="flashcard-inner">
        <div class="flashcard-front">
          <span id="card-level" class="card-level-badge"></span>
          <span id="card-word" class="card-word"></span>
          <button id="card-speak" class="card-speak-btn">üîä</button>
        </div>
        <div class="flashcard-back">
          <div id="card-sentence" class="card-back-sentence"></div>
          <img id="card-image" class="card-back-image" alt="Book page">
        </div>
      </div>
    </div>
    <button id="know-btn" class="know-btn">I Know This! ‚úì</button>
  </div>
  <div id="card-dots" class="card-dots"></div>
</div>

<!-- ===== DECK LIBRARY ===== -->
<div id="library-panel" class="screen">
  <div class="screen-header">
    <button class="back-btn" id="close-library">‚úï</button>
    <span class="screen-title">My Flashcard Decks</span>
  </div>
  <div id="library-grid" class="library-grid"></div>
</div>

<!-- ===== PROGRESS PANEL ===== -->
<div id="progress-panel" class="screen">
  <div class="screen-header">
    <button class="back-btn" id="close-progress">‚úï</button>
    <span class="screen-title">My Progress</span>
  </div>
  <div id="progress-content" class="progress-content"></div>
</div>

<!-- ===== SETTINGS ===== -->
<div id="settings-panel" class="screen">
  <div class="screen-header">
    <button class="back-btn" id="close-settings">‚úï</button>
    <span class="screen-title">Settings</span>
  </div>
  <div class="settings-content">
    <div class="setting-group">
      <label>OpenAI API Key</label>
      <input type="password" id="settings-api-key" placeholder="sk-...">
    </div>
    <div class="setting-group">
      <label>Voice</label>
      <select id="voice">
        <option value="alloy">Alloy</option>
        <option value="echo">Echo</option>
        <option value="fable" selected>Fable</option>
        <option value="nova">Nova</option>
        <option value="onyx">Onyx</option>
        <option value="shimmer">Shimmer</option>
      </select>
    </div>
    <div class="setting-group">
      <label>Speed</label>
      <select id="speed">
        <option value="0.7">Slow (0.7x)</option>
        <option value="0.9" selected>Normal (0.9x)</option>
        <option value="1.0">Fast (1.0x)</option>
      </select>
    </div>
    <button id="save-settings" class="save-settings-btn">Save Settings</button>
  </div>
</div>

<!-- Celebration container -->
<div id="celebration"></div>

<script>
const $ = (sel) => document.querySelector(sel);

// ===== STATE =====
let apiKey = localStorage.getItem('openai_api_key') || '';
let isProcessing = false;
let lastImageDataUrl = null;
let currentDeck = null;
let cardIndex = 0;
let currentAudioSource = null;
let pendingCards = [];
let pendingSentences = [];
let pendingImageDataUrl = '';

// ===== DOLCH 220 SIGHT WORDS =====
const DOLCH_LEVELS = {
  'Pre-Primer': ['a','and','away','big','blue','can','come','down','find','for','funny','go','help','here','i','in','is','it','jump','little','look','make','me','my','not','one','play','red','run','said','see','the','three','to','two','up','we','where','yellow','you'],
  'Primer': ['all','am','are','at','ate','be','black','brown','but','came','did','do','eat','four','get','good','have','he','into','like','must','new','no','now','on','our','out','please','pretty','ran','ride','saw','say','she','so','soon','that','there','they','this','too','under','want','was','well','went','what','white','who','will','with','yes'],
  'First Grade': ['after','again','an','any','as','ask','by','could','every','fly','from','give','going','had','has','her','him','his','how','just','know','let','live','may','of','old','once','open','over','put','round','some','stop','take','thank','them','then','think','walk','were','when'],
  'Second Grade': ['always','around','because','been','before','best','both','buy','call','cold','does','don\'t','fast','first','five','found','gave','goes','green','its','made','many','off','or','pull','read','right','sing','sit','sleep','tell','their','these','those','upon','us','use','very','wash','which','why','wish','work','would','write','your'],
  'Third Grade': ['about','better','bring','carry','clean','cut','done','draw','drink','eight','fall','far','full','got','grow','hold','hot','hurt','if','keep','kind','laugh','light','long','much','myself','never','only','own','pick','seven','shall','show','six','small','start','ten','today','together','try','warm']
};

const DOLCH_SET = new Set();
const DOLCH_LEVEL_MAP = {};
Object.entries(DOLCH_LEVELS).forEach(([level, words]) => {
  words.forEach(w => { DOLCH_SET.add(w); DOLCH_LEVEL_MAP[w] = level; });
});

// ===== LEARNED WORDS =====
function getLearnedWords() {
  try { return new Set(JSON.parse(localStorage.getItem('learned_words') || '[]')); }
  catch(e) { return new Set(); }
}

function saveLearnedWords(set) {
  localStorage.setItem('learned_words', JSON.stringify([...set]));
}

function addLearnedWord(word) {
  const set = getLearnedWords();
  set.add(word.toLowerCase());
  saveLearnedWords(set);
}

function removeLearnedWord(word) {
  const set = getLearnedWords();
  set.delete(word.toLowerCase());
  saveLearnedWords(set);
}

function isLearnedWord(word) {
  return getLearnedWords().has(word.toLowerCase());
}

function cleanWord(w) {
  return w.replace(/[^a-zA-Z']/g, '').toLowerCase();
}

// ===== AUDIO =====
let audioCtx = null;

async function ensureAudioContext() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') {
    await audioCtx.resume();
  }
}

function stopCurrentAudio() {
  if (currentAudioSource) {
    try { currentAudioSource.stop(); } catch(e) {}
    currentAudioSource = null;
  }
}

// ===== ELEMENTS =====
const video = $('#video');
const canvas = $('#canvas');
const ctx = canvas.getContext('2d');

// ===== CAMERA =====
async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } },
      audio: false
    });
    video.srcObject = stream;
  } catch (err) {
    showStatus('Camera access denied. Please allow camera and reload.');
  }
}

function captureFrame() {
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0);
  return canvas.toDataURL('image/jpeg', 0.6);
}

function flashEffect() {
  $('#flash').classList.add('active');
  setTimeout(() => $('#flash').classList.remove('active'), 150);
}

// ===== STATUS =====
function showStatus(msg) {
  const el = $('#status');
  el.innerHTML = `<div class="spinner"></div><span>${msg}</span>`;
  el.classList.add('visible');
}

function hideStatus() {
  $('#status').classList.remove('visible');
}

// ===== UTILS =====
function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function levelClass(level) {
  return 'level-' + level.toLowerCase().replace(/\s+/g, '-');
}

// ===== GPT-4o SENTENCE EXTRACTION =====
async function extractSentences(base64Image) {
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify({
      model: 'gpt-4o',
      max_tokens: 2048,
      messages: [
        {
          role: 'system',
          content: `You are a text extraction assistant. Extract EVERY word of visible text from this book page image.

RULES:
1. Return each sentence on its own line.
2. Preserve the exact words as written ‚Äî do NOT paraphrase or add words.
3. Do NOT describe illustrations or images.
4. Include all text: titles, captions, speech bubbles, body text.
5. For two-page spreads, read left page first, then right.
6. Return ONLY the extracted text, nothing else.`
        },
        {
          role: 'user',
          content: [
            {
              type: 'image_url',
              image_url: { url: `data:image/jpeg;base64,${base64Image}`, detail: 'low' }
            },
            {
              type: 'text',
              text: 'Extract all text from this book page.'
            }
          ]
        }
      ]
    })
  });

  if (!response.ok) {
    const err = await response.json().catch(() => ({}));
    throw new Error(err.error?.message || `API error: ${response.status}`);
  }

  const data = await response.json();
  const content = data.choices?.[0]?.message?.content?.trim();
  if (!content) return [];

  return content.split('\n').map(s => s.trim()).filter(s => s.length > 0);
}

// ===== BUILD FLASHCARDS =====
function buildFlashcards(sentences) {
  const seen = new Set();
  const learned = getLearnedWords();
  const cards = [];

  for (const sentence of sentences) {
    const words = sentence.match(/\S+/g) || [];
    for (const rawWord of words) {
      const clean = cleanWord(rawWord);
      if (DOLCH_SET.has(clean) && !seen.has(clean)) {
        seen.add(clean);
        cards.push({
          word: clean,
          sentence: sentence,
          level: DOLCH_LEVEL_MAP[clean],
          learned: learned.has(clean)
        });
      }
    }
  }

  const levelOrder = ['Pre-Primer', 'Primer', 'First Grade', 'Second Grade', 'Third Grade'];
  cards.sort((a, b) => levelOrder.indexOf(a.level) - levelOrder.indexOf(b.level));

  return cards;
}

// ===== PROCESS PAGE =====
async function processPage() {
  if (isProcessing) return;
  isProcessing = true;

  await ensureAudioContext();
  flashEffect();
  showStatus('Capturing...');

  const dataUrl = captureFrame();
  lastImageDataUrl = dataUrl;

  showStatus('Reading text...');

  try {
    const base64 = dataUrl.split(',')[1];
    const sentences = await extractSentences(base64);

    if (!sentences || sentences.length === 0) {
      hideStatus();
      showTextReview(dataUrl, [], []);
      return;
    }

    const cards = buildFlashcards(sentences);
    hideStatus();
    showTextReview(dataUrl, sentences, cards);
  } catch (err) {
    showStatus(err.message || 'Error processing page');
    setTimeout(hideStatus, 3000);
  } finally {
    isProcessing = false;
  }
}

// ===== TEXT REVIEW =====
function showTextReview(imageDataUrl, sentences, cards) {
  $('#review-image').src = imageDataUrl;

  const statsEl = $('#review-stats');
  const sightWordCount = cards.length;
  const newWords = cards.filter(c => !c.learned).length;

  if (sentences.length === 0) {
    statsEl.textContent = 'No text found on this page';
    statsEl.style.background = 'rgba(255,255,255,0.1)';
    $('#review-sentences').innerHTML =
      '<div class="no-words-msg">Try pointing the camera at a page with more text.</div>';
    $('#make-flashcards-btn').style.display = 'none';
  } else if (sightWordCount === 0) {
    statsEl.textContent = 'No sight words found';
    statsEl.style.background = 'rgba(255,255,255,0.1)';
    $('#review-sentences').innerHTML = renderSentencesHTML(sentences);
    $('#make-flashcards-btn').style.display = 'none';
  } else {
    const statsText = newWords > 0
      ? `${sightWordCount} sight word${sightWordCount !== 1 ? 's' : ''} found! (${newWords} new)`
      : `${sightWordCount} sight word${sightWordCount !== 1 ? 's' : ''} found! (all learned)`;
    statsEl.textContent = statsText;
    statsEl.style.background = '';
    $('#review-sentences').innerHTML = renderSentencesHTML(sentences);
    $('#make-flashcards-btn').style.display = '';
  }

  pendingCards = cards;
  pendingSentences = sentences;
  pendingImageDataUrl = imageDataUrl;

  $('#text-review').classList.add('visible');
}

let excludedWords = new Set();

function renderSentencesHTML(sentences) {
  const learned = getLearnedWords();
  return sentences.map(sentence => {
    const words = sentence.match(/\S+/g) || [];
    return '<p>' + words.map(word => {
      const clean = cleanWord(word);
      const isExcluded = excludedWords.has(clean);
      const exClass = isExcluded ? ' excluded' : '';
      if (learned.has(clean) && DOLCH_SET.has(clean)) {
        return `<span class="learned-word${exClass}" data-clean="${clean}">${escapeHtml(word)}</span>`;
      } else if (DOLCH_SET.has(clean)) {
        return `<span class="sight-word${exClass}" data-clean="${clean}">${escapeHtml(word)}</span>`;
      }
      return escapeHtml(word);
    }).join(' ') + '</p>';
  }).join('');
}

// Toggle word inclusion on tap in Text Review
$('#review-sentences').addEventListener('click', (e) => {
  const wordEl = e.target.closest('.sight-word, .learned-word');
  if (!wordEl) return;
  const clean = wordEl.dataset.clean;
  if (!clean) return;

  if (excludedWords.has(clean)) {
    excludedWords.delete(clean);
  } else {
    excludedWords.add(clean);
  }

  // Toggle visual on ALL instances of this word
  document.querySelectorAll(`#review-sentences [data-clean="${clean}"]`).forEach(el => {
    el.classList.toggle('excluded', excludedWords.has(clean));
  });

  // Update pending cards and stats
  pendingCards = pendingCards.map(c => ({ ...c, _excluded: excludedWords.has(c.word) }));
  const activeCards = pendingCards.filter(c => !excludedWords.has(c.word));
  const newWords = activeCards.filter(c => !c.learned).length;
  const statsEl = $('#review-stats');

  if (activeCards.length === 0) {
    statsEl.textContent = 'No sight words selected';
    statsEl.style.background = 'rgba(255,255,255,0.1)';
    $('#make-flashcards-btn').style.display = 'none';
  } else {
    const statsText = newWords > 0
      ? `${activeCards.length} sight word${activeCards.length !== 1 ? 's' : ''} selected (${newWords} new)`
      : `${activeCards.length} sight word${activeCards.length !== 1 ? 's' : ''} selected (all learned)`;
    statsEl.textContent = statsText;
    statsEl.style.background = '';
    $('#make-flashcards-btn').style.display = '';
  }
});

function closeTextReview() {
  $('#text-review').classList.remove('visible');
  excludedWords.clear();
}

// ===== FLASHCARD VIEW =====
function openFlashcardView(deck) {
  currentDeck = deck;
  cardIndex = 0;
  renderFlashcard();
  $('#flashcard-view').classList.add('visible');
}

function closeFlashcardView() {
  stopCurrentAudio();
  if (currentDeck && currentDeck.id) {
    saveDeckToDB(currentDeck);
  }
  $('#flashcard-view').classList.remove('visible');
  currentDeck = null;
}

function renderFlashcard() {
  if (!currentDeck || currentDeck.cards.length === 0) return;

  const card = currentDeck.cards[cardIndex];

  // Unflip card
  $('#flashcard').classList.remove('flipped');

  // Front
  $('#card-word').textContent = card.word;
  $('#card-level').textContent = card.level;
  $('#card-level').className = 'card-level-badge ' + levelClass(card.level);

  // Back ‚Äî sentence with highlighted word
  const sentenceWords = card.sentence.match(/\S+/g) || [];
  const sentenceHtml = sentenceWords.map(w => {
    const clean = cleanWord(w);
    if (clean === card.word) {
      return `<span class="highlight">${escapeHtml(w)}</span>`;
    }
    return escapeHtml(w);
  }).join(' ');
  $('#card-sentence').innerHTML = sentenceHtml;
  $('#card-image').src = currentDeck.imageDataUrl;

  // Counter
  $('#card-counter').textContent = `${cardIndex + 1} / ${currentDeck.cards.length}`;

  // Know button state
  const knowBtn = $('#know-btn');
  if (card.learned) {
    knowBtn.textContent = 'Learned! ‚òÖ';
    knowBtn.classList.add('known');
  } else {
    knowBtn.textContent = 'I Know This! ‚úì';
    knowBtn.classList.remove('known');
  }

  renderCardDots();
}

function renderCardDots() {
  $('#card-dots').innerHTML = currentDeck.cards.map((card, i) => {
    let cls = 'card-dot';
    if (i === cardIndex) cls += ' active';
    if (card.learned) cls += ' learned';
    return `<div class="${cls}"></div>`;
  }).join('');
}

function flipCard() {
  $('#flashcard').classList.toggle('flipped');
}

function nextCard() {
  if (!currentDeck || cardIndex >= currentDeck.cards.length - 1) return;
  cardIndex++;
  renderFlashcard();
}

function prevCard() {
  if (!currentDeck || cardIndex <= 0) return;
  cardIndex--;
  renderFlashcard();
}

function markAsKnown() {
  if (!currentDeck) return;
  const card = currentDeck.cards[cardIndex];

  if (card.learned) {
    card.learned = false;
    removeLearnedWord(card.word);
  } else {
    card.learned = true;
    addLearnedWord(card.word);
    celebrate();
  }

  renderFlashcard();

  if (currentDeck.id) {
    saveDeckToDB(currentDeck);
  }
}

// ===== TTS =====
const audioCache = new Map();

async function speakWord(word) {
  stopCurrentAudio();
  await ensureAudioContext();

  const speakBtn = $('#card-speak');
  if (speakBtn) speakBtn.classList.add('loading');

  try {
    let audioBuffer;

    // Check cache first
    const cacheKey = word.toLowerCase();
    if (audioCache.has(cacheKey)) {
      audioBuffer = audioCache.get(cacheKey);
    } else {
      const voice = localStorage.getItem('voice') || 'fable';
      const speed = 0.7;

      const response = await fetch('https://api.openai.com/v1/audio/speech', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: 'tts-1',
          input: word,
          voice: voice,
          speed: speed,
          response_format: 'mp3'
        })
      });

      if (!response.ok) throw new Error('TTS error');

      const arrayBuffer = await response.arrayBuffer();
      audioBuffer = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
      audioCache.set(cacheKey, audioBuffer);
    }

    const source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioCtx.destination);
    currentAudioSource = source;
    source.onended = () => { currentAudioSource = null; };
    source.start(0);
  } catch(e) {
    console.error('TTS failed:', e);
  } finally {
    if (speakBtn) speakBtn.classList.remove('loading');
  }
}

// ===== SWIPE & TAP GESTURES =====
let touchStartX = 0;
let touchStartY = 0;
let didSwipe = false;

const flashcardArea = $('#flashcard-area');

flashcardArea.addEventListener('touchstart', (e) => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
  didSwipe = false;
}, { passive: true });

flashcardArea.addEventListener('touchend', (e) => {
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;

  if (Math.abs(dx) > 60 && Math.abs(dx) > Math.abs(dy) + 10) {
    didSwipe = true;
    if (dx < 0) nextCard();
    else prevCard();
  }
}, { passive: true });

// Flip card on click (guarded against swipe)
$('#flashcard').addEventListener('click', (e) => {
  if (didSwipe) { didSwipe = false; return; }
  if (e.target.closest('#card-speak')) return;
  flipCard();
});

// ===== INDEXEDDB =====
const DB_NAME = 'FlashcardDB';
const DB_VERSION = 1;

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains('decks')) {
        db.createObjectStore('decks', { keyPath: 'id' });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function saveDeckToDB(deck) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction('decks', 'readwrite');
    tx.objectStore('decks').put(deck);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

async function loadDecksFromDB() {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction('decks', 'readonly');
    const req = tx.objectStore('decks').getAll();
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function deleteDeckFromDB(deckId) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction('decks', 'readwrite');
    tx.objectStore('decks').delete(deckId);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

// ===== CREATE DECK =====
async function createFlashcardDeck() {
  const activeCards = pendingCards.filter(c => !excludedWords.has(c.word));
  if (activeCards.length === 0) return;

  const firstSentence = pendingSentences[0] || 'Untitled';
  const name = firstSentence.length > 40
    ? firstSentence.substring(0, 37) + '...'
    : firstSentence;

  const deck = {
    id: 'deck-' + Date.now(),
    name: name,
    createdAt: new Date().toISOString(),
    imageDataUrl: pendingImageDataUrl,
    sentences: pendingSentences,
    cards: activeCards.map(c => ({ word: c.word, sentence: c.sentence, level: c.level, learned: c.learned }))
  };

  try {
    await saveDeckToDB(deck);
    updateLibraryBadge();
    closeTextReview();
    openFlashcardView(deck);
  } catch (err) {
    console.error('Failed to save deck:', err);
  }
}

// ===== DECK LIBRARY =====
async function openLibrary() {
  await renderLibrary();
  $('#library-panel').classList.add('visible');
}

function closeLibrary() {
  $('#library-panel').classList.remove('visible');
}

async function renderLibrary() {
  let decks = [];
  try { decks = await loadDecksFromDB(); } catch(e) { console.error(e); }

  const grid = $('#library-grid');

  if (decks.length === 0) {
    grid.innerHTML = `
      <div class="library-empty">
        <span class="empty-icon">üÉè</span>
        No flashcard decks yet!<br>Capture a book page to create one.
      </div>`;
    return;
  }

  decks.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
  const learned = getLearnedWords();

  grid.innerHTML = decks.map(deck => {
    const learnedCount = deck.cards.filter(c => learned.has(c.word)).length;
    return `
      <div class="deck-card" data-deck-id="${deck.id}">
        <button class="delete-deck-btn" data-deck-id="${deck.id}">&times;</button>
        <img src="${deck.imageDataUrl}" alt="${escapeHtml(deck.name)}">
        <div class="deck-info">
          <div class="deck-name">${escapeHtml(deck.name)}</div>
          <div class="deck-meta">
            <span>${deck.cards.length} words</span>
            <span class="learned-count">${learnedCount} learned</span>
          </div>
        </div>
      </div>`;
  }).join('');
}

$('#library-grid').addEventListener('click', async (e) => {
  const delBtn = e.target.closest('.delete-deck-btn');
  if (delBtn) {
    e.stopPropagation();
    const deckId = delBtn.dataset.deckId;
    if (confirm('Delete this deck?')) {
      await deleteDeckFromDB(deckId);
      await renderLibrary();
      updateLibraryBadge();
    }
    return;
  }

  const card = e.target.closest('.deck-card');
  if (card) {
    const deckId = card.dataset.deckId;
    try {
      const db = await openDB();
      const tx = db.transaction('decks', 'readonly');
      const req = tx.objectStore('decks').get(deckId);
      req.onsuccess = () => {
        const deck = req.result;
        if (deck) {
          const learned = getLearnedWords();
          deck.cards.forEach(c => { c.learned = learned.has(c.word); });
          closeLibrary();
          openFlashcardView(deck);
        }
      };
    } catch(e) {
      console.error('Failed to load deck:', e);
    }
  }
});

async function updateLibraryBadge() {
  try {
    const decks = await loadDecksFromDB();
    const btn = $('#library-btn');
    const existing = btn.querySelector('.deck-count');
    if (decks.length > 0) {
      if (existing) {
        existing.textContent = decks.length;
      } else {
        const span = document.createElement('span');
        span.className = 'deck-count';
        span.textContent = decks.length;
        btn.appendChild(span);
      }
    } else if (existing) {
      existing.remove();
    }
  } catch(e) {}
}

// ===== PROGRESS PANEL =====
function openProgress() {
  renderProgress();
  $('#progress-panel').classList.add('visible');
}

function closeProgress() {
  $('#progress-panel').classList.remove('visible');
}

function renderProgress() {
  const learned = getLearnedWords();
  const learnedCount = [...learned].filter(w => DOLCH_SET.has(w)).length;

  const levelColors = {
    'Pre-Primer': 'var(--pink)',
    'Primer': 'var(--yellow)',
    'First Grade': 'var(--blue)',
    'Second Grade': 'var(--purple)',
    'Third Grade': 'var(--green)'
  };

  let html = `
    <div class="progress-overall">
      <div class="progress-big-number">${learnedCount} / 220</div>
      <div class="progress-subtitle">Dolch sight words learned</div>
    </div>`;

  const levelOrder = ['Pre-Primer', 'Primer', 'First Grade', 'Second Grade', 'Third Grade'];

  for (const level of levelOrder) {
    const words = DOLCH_LEVELS[level];
    const levelLearned = words.filter(w => learned.has(w));
    const pct = Math.round((levelLearned.length / words.length) * 100);
    const color = levelColors[level];

    html += `
      <div class="level-section">
        <div class="level-header">
          <span class="level-name" style="color: ${color}">${level}</span>
          <span class="level-count">${levelLearned.length} / ${words.length}</span>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" style="width: ${pct}%; background: ${color}"></div>
        </div>
        <div class="level-words">
          ${words.map(w =>
            `<span class="word-chip${learned.has(w) ? ' learned' : ''}" data-word="${w}">${w}</span>`
          ).join('')}
        </div>
      </div>`;
  }

  $('#progress-content').innerHTML = html;
}

$('#progress-content').addEventListener('click', (e) => {
  const chip = e.target.closest('.word-chip');
  if (chip) speakWord(chip.dataset.word);
});

// ===== CELEBRATION =====
function celebrate() {
  const container = $('#celebration');
  const colors = ['#f472b6', '#fbbf24', '#60a5fa', '#a78bfa', '#4ade80', '#fb923c'];

  for (let i = 0; i < 30; i++) {
    const confetti = document.createElement('div');
    confetti.className = 'confetti';
    confetti.style.left = Math.random() * 100 + 'vw';
    confetti.style.top = Math.random() * 40 + 'vh';
    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
    confetti.style.animationDelay = Math.random() * 0.3 + 's';
    confetti.style.width = (6 + Math.random() * 8) + 'px';
    confetti.style.height = (6 + Math.random() * 8) + 'px';
    container.appendChild(confetti);
  }

  setTimeout(() => { container.innerHTML = ''; }, 1500);
}

// ===== EVENT LISTENERS =====
$('#capture-btn').addEventListener('click', async () => {
  await ensureAudioContext();
  processPage();
});

$('#library-btn').addEventListener('click', openLibrary);
$('#close-library').addEventListener('click', closeLibrary);
$('#progress-btn').addEventListener('click', openProgress);
$('#close-progress').addEventListener('click', closeProgress);
$('#close-review').addEventListener('click', closeTextReview);
$('#make-flashcards-btn').addEventListener('click', createFlashcardDeck);
$('#close-flashcards').addEventListener('click', closeFlashcardView);

$('#card-speak').addEventListener('click', (e) => {
  e.stopPropagation();
  if (currentDeck) speakWord(currentDeck.cards[cardIndex].word);
});

$('#know-btn').addEventListener('click', markAsKnown);

// Settings
$('#settings-btn').addEventListener('click', () => {
  $('#settings-api-key').value = apiKey;
  $('#voice').value = localStorage.getItem('voice') || 'fable';
  $('#speed').value = localStorage.getItem('speed') || '0.9';
  $('#settings-panel').classList.add('visible');
});

$('#close-settings').addEventListener('click', () => {
  $('#settings-panel').classList.remove('visible');
});

$('#save-settings').addEventListener('click', () => {
  const newKey = $('#settings-api-key').value.trim();
  if (newKey) {
    apiKey = newKey;
    localStorage.setItem('openai_api_key', apiKey);
  }
  localStorage.setItem('voice', $('#voice').value);
  localStorage.setItem('speed', $('#speed').value);
  $('#settings-panel').classList.remove('visible');
});

// API key overlay
$('#submit-api-key').addEventListener('click', async () => {
  const key = $('#initial-api-key').value.trim();
  if (!key) return;
  await ensureAudioContext();
  apiKey = key;
  localStorage.setItem('openai_api_key', apiKey);
  $('#api-key-overlay').classList.add('hidden');
  startCamera();
});

$('#initial-api-key').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') $('#submit-api-key').click();
});

// ===== INIT =====
function init() {
  if (apiKey) {
    $('#api-key-overlay').classList.add('hidden');
    startCamera();
  }
  updateLibraryBadge();
}

init();
</script>
</body>
</html>
