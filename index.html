<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Flashcards">
<meta name="theme-color" content="#1a1a2e">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-180.png">
<title>‰Ωë‰ΩëÁöÑËÆ§Â≠óÂç°</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@600;700;800&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --pink: #f472b6;
    --pink-light: #f9a8d4;
    --pink-hot: #ec4899;
    --yellow: #fbbf24;
    --orange: #fb923c;
    --purple: #a78bfa;
    --blue: #60a5fa;
    --green: #4ade80;
    --bg-warm: #1e1026;
    --bg-card: #2e1f3d;
    --radius: 20px;
  }

  body {
    font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
    background: var(--bg-warm);
    color: #fff;
    height: 100dvh;
    overflow: hidden;
    touch-action: manipulation;
  }

  /* ===== HOME (LIBRARY) ===== */
  #home {
    position: relative;
    width: 100%;
    height: 100dvh;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  .home-header {
    display: flex;
    align-items: center;
    padding: 12px 16px;
    gap: 10px;
    background: rgba(30,16,38,0.95);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    position: sticky;
    top: 0;
    z-index: 5;
  }

  .home-header-actions {
    display: flex;
    gap: 8px;
    margin-left: auto;
  }

  .home-header-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none;
    background: rgba(255,255,255,0.1);
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .camera-fab {
    position: fixed;
    bottom: 32px;
    right: 24px;
    width: 64px;
    height: 64px;
    border-radius: 50%;
    border: none;
    background: linear-gradient(135deg, var(--pink-hot), var(--purple));
    font-size: 32px;
    cursor: pointer;
    z-index: 40;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 20px rgba(236,72,153,0.4);
    transition: transform 0.15s;
  }

  .camera-fab:active { transform: scale(0.9); }

  /* ===== CAMERA ===== */
  #camera-container {
    position: fixed;
    inset: 0;
    background: #000;
    z-index: 50;
    display: none;
  }

  #camera-container.visible { display: block; }

  #video {
    width: 100%;
    height: 100dvh;
    object-fit: cover;
  }

  #canvas { display: none; }

  #camera-frame {
    position: absolute;
    inset: 12px;
    border: 3px dashed rgba(255,255,255,0.25);
    border-radius: 24px;
    pointer-events: none;
    z-index: 2;
  }

  #top-bar {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding: 12px 16px 16px;
    background: linear-gradient(to bottom, rgba(30,16,38,0.9) 0%, transparent 100%);
    z-index: 10;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  #mascot {
    font-size: 36px;
    animation: wiggle 2s ease-in-out infinite;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
  }

  @keyframes wiggle {
    0%, 100% { transform: rotate(-5deg); }
    50% { transform: rotate(5deg); }
  }

  #app-title {
    display: flex;
    flex-direction: column;
    line-height: 1.1;
  }

  #app-title .cn {
    font-size: 20px;
    font-weight: 800;
    background: linear-gradient(135deg, var(--pink), var(--yellow));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  #app-title .en {
    font-size: 11px;
    font-weight: 600;
    color: rgba(255,255,255,0.6);
  }

  #capture-btn {
    position: absolute;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: 4px solid white;
    background: rgba(244, 114, 182, 0.8);
    font-size: 36px;
    cursor: pointer;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    transition: transform 0.15s;
  }

  #capture-btn:active {
    transform: translateX(-50%) scale(0.9);
  }

  #close-camera {
    position: absolute;
    top: 16px;
    left: 16px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: none;
    background: rgba(0,0,0,0.5);
    color: white;
    font-size: 22px;
    cursor: pointer;
    z-index: 11;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  #hint {
    position: absolute;
    bottom: 130px;
    left: 0;
    right: 0;
    text-align: center;
    font-size: 16px;
    font-weight: 700;
    color: rgba(255,255,255,0.7);
    z-index: 10;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
  }

  #status {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(30,16,38,0.95);
    padding: 16px 28px;
    border-radius: 16px;
    font-size: 16px;
    font-weight: 700;
    display: none;
    align-items: center;
    gap: 12px;
    z-index: 20;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
  }

  #status.visible { display: flex; }

  .spinner {
    width: 24px;
    height: 24px;
    border: 3px solid rgba(255,255,255,0.2);
    border-top-color: var(--pink);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  #flash {
    position: absolute;
    inset: 0;
    background: white;
    opacity: 0;
    pointer-events: none;
    z-index: 30;
    transition: opacity 0.15s;
  }

  #flash.active { opacity: 0.8; }

  /* ===== SCREEN OVERLAYS ===== */
  .screen {
    position: fixed;
    inset: 0;
    background: var(--bg-warm);
    z-index: 50;
    display: none;
    flex-direction: column;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  .screen.visible { display: flex; }

  .screen-header {
    display: flex;
    align-items: center;
    padding: 12px 16px;
    gap: 12px;
    background: rgba(30,16,38,0.95);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    position: sticky;
    top: 0;
    z-index: 5;
  }

  .back-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none;
    background: rgba(255,255,255,0.1);
    color: white;
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }

  .screen-title {
    font-size: 18px;
    font-weight: 800;
    flex: 1;
  }

  /* ===== API KEY OVERLAY ===== */
  #api-key-overlay {
    position: fixed;
    inset: 0;
    background: var(--bg-warm);
    z-index: 100;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 24px;
    gap: 16px;
    text-align: center;
  }

  #api-key-overlay.hidden { display: none; }
  #api-key-overlay .emoji { font-size: 64px; }

  #api-key-overlay h2 {
    font-size: 24px;
    background: linear-gradient(135deg, var(--pink), var(--yellow));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  #api-key-overlay input {
    width: 100%;
    max-width: 320px;
    padding: 14px 16px;
    border-radius: 12px;
    border: 2px solid rgba(255,255,255,0.1);
    background: var(--bg-card);
    color: white;
    font-size: 16px;
    font-family: inherit;
    outline: none;
  }

  #api-key-overlay input:focus { border-color: var(--pink); }

  #api-key-overlay button {
    padding: 14px 40px;
    border-radius: 12px;
    border: none;
    background: linear-gradient(135deg, var(--pink-hot), var(--purple));
    color: white;
    font-size: 18px;
    font-weight: 800;
    cursor: pointer;
    font-family: inherit;
  }

  /* ===== TEXT REVIEW ===== */
  .review-image {
    width: 100%;
    max-height: 35vh;
    object-fit: contain;
    background: #000;
  }

  .review-body {
    padding: 20px 16px;
    flex: 1;
  }

  .review-stats {
    background: linear-gradient(135deg, var(--pink), var(--purple));
    padding: 12px 16px;
    border-radius: 12px;
    font-size: 18px;
    font-weight: 800;
    text-align: center;
    margin-bottom: 16px;
  }

  .review-sentences {
    background: var(--bg-card);
    border-radius: 16px;
    padding: 16px;
    margin-bottom: 20px;
    font-size: 18px;
    line-height: 1.8;
  }

  .review-sentences p { margin-bottom: 8px; }
  .review-sentences p:last-child { margin-bottom: 0; }

  .sight-word {
    background: rgba(244, 114, 182, 0.3);
    color: var(--pink-light);
    padding: 2px 6px;
    border-radius: 6px;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.2s;
  }

  .sight-word.excluded {
    background: rgba(255,255,255,0.05);
    color: rgba(255,255,255,0.3);
    text-decoration: line-through;
  }

  .learned-word {
    background: rgba(74, 222, 128, 0.3);
    color: var(--green);
    padding: 2px 6px;
    border-radius: 6px;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.2s;
  }

  .learned-word.excluded {
    background: rgba(255,255,255,0.05);
    color: rgba(255,255,255,0.3);
    text-decoration: line-through;
  }

  .make-flashcards-btn {
    width: 100%;
    padding: 18px;
    border-radius: 16px;
    border: none;
    background: linear-gradient(135deg, var(--pink-hot), var(--orange));
    color: white;
    font-size: 20px;
    font-weight: 800;
    cursor: pointer;
    font-family: inherit;
    box-shadow: 0 4px 20px rgba(236, 72, 153, 0.4);
  }

  .make-flashcards-btn:active { transform: scale(0.97); }

  .no-words-msg {
    text-align: center;
    color: rgba(255,255,255,0.5);
    font-size: 16px;
    padding: 20px;
  }

  /* ===== FLASHCARD VIEW ===== */
  #flashcard-view { overflow: hidden; }

  .card-counter {
    font-size: 16px;
    font-weight: 700;
    color: rgba(255,255,255,0.6);
  }

  .flashcard-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    gap: 20px;
    overflow: hidden;
  }

  /* 3D Flashcard */
  .flashcard {
    perspective: 1200px;
    width: calc(100vw - 48px);
    max-width: 340px;
    height: 420px;
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
  }

  .flashcard-inner {
    position: relative;
    width: 100%;
    height: 100%;
    transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    transform-style: preserve-3d;
  }

  .flashcard.flipped .flashcard-inner {
    transform: rotateY(180deg);
  }

  .flashcard-front, .flashcard-back {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
    border-radius: 24px;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow: hidden;
    -webkit-transform: translateZ(0);
  }

  .flashcard-front {
    background: var(--card-bg, linear-gradient(160deg, #3b2450, #2e1f3d));
    border: 2px solid var(--card-border, rgba(255,255,255,0.1));
    justify-content: center;
    gap: 20px;
    padding: 24px;
  }

  .flashcard-back {
    background: linear-gradient(160deg, #2a1835, #1e1026);
    border: 2px solid rgba(255,255,255,0.1);
    transform: rotateY(180deg);
    padding: 0;
  }

  .card-level-badge {
    padding: 6px 14px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .level-pre-primer { background: rgba(244,114,182,0.2); color: var(--pink-light); }
  .level-primer { background: rgba(251,191,36,0.2); color: var(--yellow); }
  .level-first-grade { background: rgba(96,165,250,0.2); color: var(--blue); }
  .level-second-grade { background: rgba(167,139,250,0.2); color: var(--purple); }
  .level-third-grade { background: rgba(74,222,128,0.2); color: var(--green); }

  .card-word {
    font-size: 56px;
    font-weight: 800;
    text-align: center;
    text-shadow: 0 2px 8px rgba(0,0,0,0.3);
  }

  .card-speak-btn {
    width: 56px;
    height: 56px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1);
    font-size: 28px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    pointer-events: auto;
  }

  .card-speak-btn:active { background: rgba(255,255,255,0.2); }
  .card-speak-btn.loading { opacity: 0.5; }

  .card-back-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    gap: 12px;
  }

  .card-back-sentence {
    font-size: 20px;
    line-height: 1.6;
    text-align: center;
  }

  .card-back-sentence .highlight {
    background: rgba(244,114,182,0.3);
    color: var(--pink-light);
    padding: 2px 6px;
    border-radius: 6px;
    font-weight: 800;
  }

  .card-back-sentence .word-span {
    transition: all 0.15s;
    padding: 1px 2px;
    border-radius: 4px;
  }

  .card-back-sentence .word-span.speaking {
    background: rgba(251,191,36,0.4);
    color: var(--yellow);
    font-weight: 800;
  }

  .card-sentence-speak {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1);
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: auto;
    position: relative;
    flex-shrink: 0;
  }

  .card-sentence-speak:active { background: rgba(255,255,255,0.2); }

  .card-back-image {
    width: 100%;
    height: 170px;
    object-fit: contain;
    background: #000;
    border-radius: 0 0 22px 22px;
  }

  .know-btn {
    padding: 16px 40px;
    border-radius: 16px;
    border: none;
    background: linear-gradient(135deg, var(--green), #22c55e);
    color: white;
    font-size: 18px;
    font-weight: 800;
    cursor: pointer;
    font-family: inherit;
    box-shadow: 0 4px 16px rgba(74,222,128,0.3);
    transition: all 0.2s;
  }

  .know-btn:active { transform: scale(0.95); }

  .know-btn.known {
    background: rgba(74,222,128,0.2);
    color: var(--green);
    box-shadow: none;
  }

  .card-dots {
    display: flex;
    gap: 6px;
    justify-content: center;
    padding: 12px 0 24px;
    flex-wrap: wrap;
    max-width: 90vw;
    margin: 0 auto;
  }

  .card-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: rgba(255,255,255,0.2);
    transition: all 0.3s;
  }

  .card-dot.active {
    background: var(--pink);
    width: 24px;
    border-radius: 4px;
  }

  .card-dot.learned { background: var(--green); }

  /* Swipe animation */
  .flashcard.swipe-left {
    animation: swipeLeft 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  }
  .flashcard.swipe-right {
    animation: swipeRight 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  }

  @keyframes swipeLeft {
    0% { transform: translateX(0) rotate(0deg) scale(1); opacity: 1; }
    35% { transform: translateX(-120%) rotate(-15deg) scale(0.85); opacity: 0; }
    36% { transform: translateX(100%) rotate(10deg) scale(0.85); opacity: 0; }
    100% { transform: translateX(0) rotate(0deg) scale(1); opacity: 1; }
  }

  @keyframes swipeRight {
    0% { transform: translateX(0) rotate(0deg) scale(1); opacity: 1; }
    35% { transform: translateX(120%) rotate(15deg) scale(0.85); opacity: 0; }
    36% { transform: translateX(-100%) rotate(-10deg) scale(0.85); opacity: 0; }
    100% { transform: translateX(0) rotate(0deg) scale(1); opacity: 1; }
  }

  /* ===== DECK LIBRARY ===== */
  .study-all-bar {
    padding: 16px 16px 0;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .study-all-btn {
    flex: 1;
    padding: 16px;
    border-radius: 16px;
    border: none;
    background: linear-gradient(135deg, var(--pink-hot), var(--purple));
    color: white;
    font-size: 18px;
    font-weight: 800;
    cursor: pointer;
    font-family: inherit;
    box-shadow: 0 4px 16px rgba(236,72,153,0.3);
  }

  .study-all-btn:active { transform: scale(0.97); }

  .study-all-count {
    font-size: 13px;
    color: rgba(255,255,255,0.5);
    white-space: nowrap;
  }

  .library-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    padding: 16px;
  }

  .word-card {
    background: var(--bg-card);
    border-radius: 16px;
    padding: 18px 8px;
    cursor: pointer;
    text-align: center;
    transition: transform 0.15s;
    border: 2px solid transparent;
  }

  .word-card:active { transform: scale(0.93); }

  .word-card-word {
    font-size: 22px;
    font-weight: 800;
    color: white;
    line-height: 1.2;
  }

  .word-card-level {
    font-size: 10px;
    font-weight: 600;
    margin-top: 6px;
    opacity: 0.6;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .word-card.learned {
    opacity: 0.5;
  }

  .word-card.learned .word-card-word {
    text-decoration: line-through;
  }

  .word-card.learned::after {
    content: '‚úì';
    display: block;
    font-size: 14px;
    margin-top: 4px;
    color: var(--green);
  }

  .manage-decks-bar {
    padding: 0 16px 8px;
    display: flex;
    justify-content: flex-end;
  }

  .manage-decks-btn {
    background: none;
    border: none;
    color: rgba(255,255,255,0.4);
    font-size: 13px;
    font-family: inherit;
    cursor: pointer;
    padding: 4px 8px;
  }

  .manage-decks-btn:active { color: rgba(255,255,255,0.7); }

  .library-empty {
    grid-column: 1 / -1;
    text-align: center;
    padding: 60px 20px;
    color: rgba(255,255,255,0.4);
    font-size: 16px;
  }

  .library-empty .empty-icon {
    font-size: 48px;
    display: block;
    margin-bottom: 12px;
  }

  /* ===== PROGRESS PANEL ===== */
  .progress-content { padding: 16px; }

  .progress-overall {
    text-align: center;
    padding: 24px;
    background: linear-gradient(135deg, rgba(244,114,182,0.15), rgba(167,139,250,0.15));
    border-radius: 20px;
    margin-bottom: 20px;
  }

  .progress-big-number {
    font-size: 48px;
    font-weight: 800;
    background: linear-gradient(135deg, var(--pink), var(--yellow));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .progress-subtitle {
    font-size: 14px;
    color: rgba(255,255,255,0.6);
    margin-top: 4px;
  }

  .level-section { margin-bottom: 16px; }

  .level-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }

  .level-name { font-size: 15px; font-weight: 700; }
  .level-count { font-size: 13px; color: rgba(255,255,255,0.5); }

  .progress-bar {
    height: 12px;
    background: rgba(255,255,255,0.1);
    border-radius: 6px;
    overflow: hidden;
    margin-bottom: 8px;
  }

  .progress-fill {
    height: 100%;
    border-radius: 6px;
    transition: width 0.5s ease;
  }

  .level-words {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .word-chip {
    padding: 4px 10px;
    border-radius: 8px;
    font-size: 12px;
    font-weight: 700;
    background: rgba(255,255,255,0.1);
    color: rgba(255,255,255,0.4);
    cursor: pointer;
  }

  .word-chip.learned {
    background: rgba(74,222,128,0.2);
    color: var(--green);
  }

  /* ===== SETTINGS ===== */
  .settings-content {
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .setting-group {
    background: var(--bg-card);
    border-radius: 16px;
    padding: 16px;
  }

  .setting-group label {
    display: block;
    font-size: 14px;
    font-weight: 700;
    color: rgba(255,255,255,0.6);
    margin-bottom: 8px;
  }

  .setting-group input, .setting-group select {
    width: 100%;
    padding: 12px;
    border-radius: 10px;
    border: 2px solid rgba(255,255,255,0.1);
    background: rgba(0,0,0,0.2);
    color: white;
    font-size: 16px;
    font-family: inherit;
    outline: none;
  }

  .setting-group input:focus, .setting-group select:focus {
    border-color: var(--pink);
  }

  .setting-group select option { background: var(--bg-card); }

  .save-settings-btn {
    padding: 16px;
    border-radius: 16px;
    border: none;
    background: linear-gradient(135deg, var(--pink-hot), var(--purple));
    color: white;
    font-size: 18px;
    font-weight: 800;
    cursor: pointer;
    font-family: inherit;
  }

  /* ===== CELEBRATION ===== */
  #celebration {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 200;
  }

  .confetti {
    position: absolute;
    width: 10px;
    height: 10px;
    border-radius: 2px;
    animation: confetti-fall 1.2s ease-out forwards;
  }

  @keyframes confetti-fall {
    0% { transform: translateY(0) rotate(0deg) scale(1); opacity: 1; }
    100% { transform: translateY(100vh) rotate(720deg) scale(0); opacity: 0; }
  }

  /* ===== RESPONSIVE ===== */
  @media (min-width: 768px) {
    .flashcard { max-width: 380px; height: 480px; }
    .library-grid { grid-template-columns: repeat(3, 1fr); }
  }
</style>
</head>
<body>

<!-- ===== HOME SCREEN (Library) ===== -->
<div id="home">
  <div class="home-header">
    <div id="mascot">üÉè</div>
    <div id="app-title">
      <span class="cn">‰Ωë‰ΩëÁöÑËÆ§Â≠óÂç°</span>
      <span class="en">Hunter's Flashcards</span>
    </div>
    <div class="home-header-actions">
      <button class="home-header-btn" id="progress-btn">‚≠ê</button>
      <button class="home-header-btn" id="settings-btn">‚öôÔ∏è</button>
    </div>
  </div>
  <div id="study-all-bar" class="study-all-bar" style="display:none">
    <button id="study-all-btn" class="study-all-btn">üìñ Study All Words</button>
    <span id="study-all-count" class="study-all-count"></span>
  </div>
  <div id="manage-decks-bar" class="manage-decks-bar" style="display:none">
    <button id="manage-decks-btn" class="manage-decks-btn">Manage Decks</button>
  </div>
  <div id="library-grid" class="library-grid"></div>
</div>

<button id="camera-fab" class="camera-fab">üì∑</button>

<!-- ===== CAMERA OVERLAY ===== -->
<div id="camera-container">
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>
  <div id="flash"></div>
  <div id="camera-frame"></div>
  <button id="close-camera">‚úï</button>
  <div id="hint">Point at a book page, then tap!</div>
  <button id="capture-btn">üì∏</button>
  <div id="status"></div>
</div>

<!-- ===== API KEY OVERLAY ===== -->
<div id="api-key-overlay">
  <div class="emoji">üÉè</div>
  <h2>‰Ωë‰ΩëÁöÑËÆ§Â≠óÂç°</h2>
  <p style="color: rgba(255,255,255,0.6); font-size: 14px;">
    Enter your OpenAI API key to get started
  </p>
  <input type="password" id="initial-api-key" placeholder="sk-...">
  <button id="submit-api-key">Let's Go!</button>
</div>

<!-- ===== TEXT REVIEW ===== -->
<div id="text-review" class="screen">
  <div class="screen-header">
    <button class="back-btn" id="close-review">‚úï</button>
    <span class="screen-title">Text Found</span>
  </div>
  <img id="review-image" class="review-image" alt="Captured page">
  <div class="review-body">
    <div id="review-stats" class="review-stats"></div>
    <div id="review-sentences" class="review-sentences"></div>
    <button id="make-flashcards-btn" class="make-flashcards-btn">üÉè Make Flashcards!</button>
  </div>
</div>

<!-- ===== FLASHCARD VIEW ===== -->
<div id="flashcard-view" class="screen">
  <div class="screen-header">
    <button class="back-btn" id="close-flashcards">‚úï</button>
    <span class="screen-title">Flashcards</span>
    <span id="card-counter" class="card-counter"></span>
  </div>
  <div class="flashcard-area" id="flashcard-area">
    <div class="flashcard" id="flashcard">
      <div class="flashcard-inner" id="flashcard-inner">
        <div class="flashcard-front">
          <span id="card-level" class="card-level-badge"></span>
          <span id="card-word" class="card-word"></span>
          <button id="card-speak" class="card-speak-btn">üîä</button>
        </div>
        <div class="flashcard-back">
          <div class="card-back-content">
            <div id="card-sentence" class="card-back-sentence"></div>
            <button id="card-sentence-speak" class="card-sentence-speak">üîä</button>
          </div>
          <img id="card-image" class="card-back-image" alt="Book page">
        </div>
      </div>
    </div>
    <button id="know-btn" class="know-btn">I Know This! ‚úì</button>
  </div>
  <div id="card-dots" class="card-dots"></div>
</div>

<!-- ===== PROGRESS PANEL ===== -->
<div id="progress-panel" class="screen">
  <div class="screen-header">
    <button class="back-btn" id="close-progress">‚úï</button>
    <span class="screen-title">My Progress</span>
  </div>
  <div id="progress-content" class="progress-content"></div>
</div>

<!-- ===== SETTINGS ===== -->
<div id="settings-panel" class="screen">
  <div class="screen-header">
    <button class="back-btn" id="close-settings">‚úï</button>
    <span class="screen-title">Settings</span>
  </div>
  <div class="settings-content">
    <div class="setting-group">
      <label>OpenAI API Key</label>
      <input type="password" id="settings-api-key" placeholder="sk-...">
    </div>
    <div class="setting-group">
      <label>Voice</label>
      <select id="voice">
        <option value="alloy">Alloy</option>
        <option value="echo">Echo</option>
        <option value="fable" selected>Fable</option>
        <option value="nova">Nova</option>
        <option value="onyx">Onyx</option>
        <option value="shimmer">Shimmer</option>
      </select>
    </div>
    <div class="setting-group">
      <label>Speed</label>
      <select id="speed">
        <option value="0.7">Slow (0.7x)</option>
        <option value="0.9" selected>Normal (0.9x)</option>
        <option value="1.0">Fast (1.0x)</option>
      </select>
    </div>
    <button id="save-settings" class="save-settings-btn">Save Settings</button>
  </div>
</div>

<!-- Celebration container -->
<div id="celebration"></div>

<script>
const $ = (sel) => document.querySelector(sel);

// ===== STATE =====
let apiKey = localStorage.getItem('openai_api_key') || '';
let isProcessing = false;
let lastImageDataUrl = null;
let currentDeck = null;
let cardIndex = 0;
let currentAudioSource = null;
let pendingCards = [];
let pendingSentences = [];
let pendingImageDataUrl = '';

// ===== DOLCH 220 SIGHT WORDS =====
const DOLCH_LEVELS = {
  'Pre-Primer': ['a','and','away','big','blue','can','come','down','find','for','funny','go','help','here','i','in','is','it','jump','little','look','make','me','my','not','one','play','red','run','said','see','the','three','to','two','up','we','where','yellow','you'],
  'Primer': ['all','am','are','at','ate','be','black','brown','but','came','did','do','eat','four','get','good','have','he','into','like','must','new','no','now','on','our','out','please','pretty','ran','ride','saw','say','she','so','soon','that','there','they','this','too','under','want','was','well','went','what','white','who','will','with','yes'],
  'First Grade': ['after','again','an','any','as','ask','by','could','every','fly','from','give','going','had','has','her','him','his','how','just','know','let','live','may','of','old','once','open','over','put','round','some','stop','take','thank','them','then','think','walk','were','when'],
  'Second Grade': ['always','around','because','been','before','best','both','buy','call','cold','does','don\'t','fast','first','five','found','gave','goes','green','its','made','many','off','or','pull','read','right','sing','sit','sleep','tell','their','these','those','upon','us','use','very','wash','which','why','wish','work','would','write','your'],
  'Third Grade': ['about','better','bring','carry','clean','cut','done','draw','drink','eight','fall','far','full','got','grow','hold','hot','hurt','if','keep','kind','laugh','light','long','much','myself','never','only','own','pick','seven','shall','show','six','small','start','ten','today','together','try','warm']
};

const DOLCH_SET = new Set();
const DOLCH_LEVEL_MAP = {};
Object.entries(DOLCH_LEVELS).forEach(([level, words]) => {
  words.forEach(w => { DOLCH_SET.add(w); DOLCH_LEVEL_MAP[w] = level; });
});

// ===== LEARNED WORDS =====
function getLearnedWords() {
  try { return new Set(JSON.parse(localStorage.getItem('learned_words') || '[]')); }
  catch(e) { return new Set(); }
}

function saveLearnedWords(set) {
  localStorage.setItem('learned_words', JSON.stringify([...set]));
}

function addLearnedWord(word) {
  const set = getLearnedWords();
  set.add(word.toLowerCase());
  saveLearnedWords(set);
}

function removeLearnedWord(word) {
  const set = getLearnedWords();
  set.delete(word.toLowerCase());
  saveLearnedWords(set);
}

function isLearnedWord(word) {
  return getLearnedWords().has(word.toLowerCase());
}

function cleanWord(w) {
  return w.replace(/[^a-zA-Z']/g, '').toLowerCase();
}

// ===== AUDIO =====
let audioCtx = null;

async function ensureAudioContext() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') {
    await audioCtx.resume();
  }
}

function stopCurrentAudio() {
  if (currentAudioSource) {
    try { currentAudioSource.stop(); } catch(e) {}
    currentAudioSource = null;
  }
  if (typeof clearWordHighlights === 'function') clearWordHighlights();
}

// ===== ELEMENTS =====
const video = $('#video');
const canvas = $('#canvas');
const ctx = canvas.getContext('2d');

// ===== CAMERA =====
async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } },
      audio: false
    });
    video.srcObject = stream;
  } catch (err) {
    showStatus('Camera access denied. Please allow camera and reload.');
  }
}

function stopCamera() {
  if (video.srcObject) {
    video.srcObject.getTracks().forEach(t => t.stop());
    video.srcObject = null;
  }
}

async function openCamera() {
  await ensureAudioContext();
  await startCamera();
  $('#camera-container').classList.add('visible');
}

function closeCamera() {
  stopCamera();
  $('#camera-container').classList.remove('visible');
}

function captureFrame() {
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0);
  return canvas.toDataURL('image/jpeg', 0.6);
}

function flashEffect() {
  $('#flash').classList.add('active');
  setTimeout(() => $('#flash').classList.remove('active'), 150);
}

// ===== STATUS =====
function showStatus(msg) {
  const el = $('#status');
  el.innerHTML = `<div class="spinner"></div><span>${msg}</span>`;
  el.classList.add('visible');
}

function hideStatus() {
  $('#status').classList.remove('visible');
}

// ===== UTILS =====
function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function levelClass(level) {
  return 'level-' + level.toLowerCase().replace(/\s+/g, '-');
}

// ===== GPT-4o SENTENCE EXTRACTION =====
async function extractSentences(base64Image) {
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify({
      model: 'gpt-4o',
      max_tokens: 2048,
      messages: [
        {
          role: 'system',
          content: `You are a text extraction assistant. Extract EVERY word of visible text from this book page image.

RULES:
1. Return each sentence on its own line.
2. Preserve the exact words as written ‚Äî do NOT paraphrase or add words.
3. Do NOT describe illustrations or images.
4. Include all text: titles, captions, speech bubbles, body text.
5. For two-page spreads, read left page first, then right.
6. Return ONLY the extracted text, nothing else.`
        },
        {
          role: 'user',
          content: [
            {
              type: 'image_url',
              image_url: { url: `data:image/jpeg;base64,${base64Image}`, detail: 'low' }
            },
            {
              type: 'text',
              text: 'Extract all text from this book page.'
            }
          ]
        }
      ]
    })
  });

  if (!response.ok) {
    const err = await response.json().catch(() => ({}));
    throw new Error(err.error?.message || `API error: ${response.status}`);
  }

  const data = await response.json();
  const content = data.choices?.[0]?.message?.content?.trim();
  if (!content) return [];

  return content.split('\n').map(s => s.trim()).filter(s => s.length > 0);
}

// ===== BUILD FLASHCARDS =====
function buildFlashcards(sentences) {
  const seen = new Set();
  const learned = getLearnedWords();
  const cards = [];

  for (const sentence of sentences) {
    const words = sentence.match(/\S+/g) || [];
    for (const rawWord of words) {
      const clean = cleanWord(rawWord);
      if (DOLCH_SET.has(clean) && !seen.has(clean)) {
        seen.add(clean);
        cards.push({
          word: clean,
          sentence: sentence,
          level: DOLCH_LEVEL_MAP[clean],
          learned: learned.has(clean)
        });
      }
    }
  }

  const levelOrder = ['Pre-Primer', 'Primer', 'First Grade', 'Second Grade', 'Third Grade'];
  cards.sort((a, b) => levelOrder.indexOf(a.level) - levelOrder.indexOf(b.level));

  return cards;
}

// ===== PROCESS PAGE =====
async function processPage() {
  if (isProcessing) return;
  isProcessing = true;

  await ensureAudioContext();
  flashEffect();
  showStatus('Capturing...');

  const dataUrl = captureFrame();
  lastImageDataUrl = dataUrl;

  showStatus('Reading text...');

  try {
    const base64 = dataUrl.split(',')[1];
    const sentences = await extractSentences(base64);

    if (!sentences || sentences.length === 0) {
      hideStatus();
      showTextReview(dataUrl, [], []);
      return;
    }

    const cards = buildFlashcards(sentences);
    hideStatus();
    showTextReview(dataUrl, sentences, cards);
  } catch (err) {
    showStatus(err.message || 'Error processing page');
    setTimeout(hideStatus, 3000);
  } finally {
    isProcessing = false;
  }
}

// ===== TEXT REVIEW =====
function showTextReview(imageDataUrl, sentences, cards) {
  $('#review-image').src = imageDataUrl;

  const statsEl = $('#review-stats');
  const sightWordCount = cards.length;
  const newWords = cards.filter(c => !c.learned).length;

  if (sentences.length === 0) {
    statsEl.textContent = 'No text found on this page';
    statsEl.style.background = 'rgba(255,255,255,0.1)';
    $('#review-sentences').innerHTML =
      '<div class="no-words-msg">Try pointing the camera at a page with more text.</div>';
    $('#make-flashcards-btn').style.display = 'none';
  } else if (sightWordCount === 0) {
    statsEl.textContent = 'No sight words found';
    statsEl.style.background = 'rgba(255,255,255,0.1)';
    $('#review-sentences').innerHTML = renderSentencesHTML(sentences);
    $('#make-flashcards-btn').style.display = 'none';
  } else {
    const statsText = newWords > 0
      ? `${sightWordCount} sight word${sightWordCount !== 1 ? 's' : ''} found! (${newWords} new)`
      : `${sightWordCount} sight word${sightWordCount !== 1 ? 's' : ''} found! (all learned)`;
    statsEl.textContent = statsText;
    statsEl.style.background = '';
    $('#review-sentences').innerHTML = renderSentencesHTML(sentences);
    $('#make-flashcards-btn').style.display = '';
  }

  pendingCards = cards;
  pendingSentences = sentences;
  pendingImageDataUrl = imageDataUrl;

  $('#text-review').classList.add('visible');
}

let excludedWords = new Set();

function renderSentencesHTML(sentences) {
  const learned = getLearnedWords();
  return sentences.map(sentence => {
    const words = sentence.match(/\S+/g) || [];
    return '<p>' + words.map(word => {
      const clean = cleanWord(word);
      const isExcluded = excludedWords.has(clean);
      const exClass = isExcluded ? ' excluded' : '';
      if (learned.has(clean) && DOLCH_SET.has(clean)) {
        return `<span class="learned-word${exClass}" data-clean="${clean}">${escapeHtml(word)}</span>`;
      } else if (DOLCH_SET.has(clean)) {
        return `<span class="sight-word${exClass}" data-clean="${clean}">${escapeHtml(word)}</span>`;
      }
      return escapeHtml(word);
    }).join(' ') + '</p>';
  }).join('');
}

// Toggle word inclusion on tap in Text Review
$('#review-sentences').addEventListener('click', (e) => {
  const wordEl = e.target.closest('.sight-word, .learned-word');
  if (!wordEl) return;
  const clean = wordEl.dataset.clean;
  if (!clean) return;

  if (excludedWords.has(clean)) {
    excludedWords.delete(clean);
  } else {
    excludedWords.add(clean);
  }

  // Toggle visual on ALL instances of this word
  document.querySelectorAll(`#review-sentences [data-clean="${clean}"]`).forEach(el => {
    el.classList.toggle('excluded', excludedWords.has(clean));
  });

  // Update pending cards and stats
  pendingCards = pendingCards.map(c => ({ ...c, _excluded: excludedWords.has(c.word) }));
  const activeCards = pendingCards.filter(c => !excludedWords.has(c.word));
  const newWords = activeCards.filter(c => !c.learned).length;
  const statsEl = $('#review-stats');

  if (activeCards.length === 0) {
    statsEl.textContent = 'No sight words selected';
    statsEl.style.background = 'rgba(255,255,255,0.1)';
    $('#make-flashcards-btn').style.display = 'none';
  } else {
    const statsText = newWords > 0
      ? `${activeCards.length} sight word${activeCards.length !== 1 ? 's' : ''} selected (${newWords} new)`
      : `${activeCards.length} sight word${activeCards.length !== 1 ? 's' : ''} selected (all learned)`;
    statsEl.textContent = statsText;
    statsEl.style.background = '';
    $('#make-flashcards-btn').style.display = '';
  }
});

function closeTextReview() {
  $('#text-review').classList.remove('visible');
  excludedWords.clear();
}

// ===== FLASHCARD VIEW =====
function openFlashcardView(deck, startIndex) {
  currentDeck = deck;
  cardIndex = startIndex || 0;
  renderFlashcard();
  $('#flashcard-view').classList.add('visible');
}

function closeFlashcardView() {
  stopCurrentAudio();
  if (currentDeck && currentDeck.id) {
    saveDeckToDB(currentDeck);
  }
  $('#flashcard-view').classList.remove('visible');
  currentDeck = null;
}

function renderFlashcard() {
  if (!currentDeck || currentDeck.cards.length === 0) return;

  const card = currentDeck.cards[cardIndex];

  // Unflip card
  $('#flashcard').classList.remove('flipped');

  // Front ‚Äî unique color per card using index-based hue rotation
  const palette = [
    { h1: '#4a1942', h2: '#2e1f3d', border: 'rgba(244,114,182,0.3)' },  // pink
    { h1: '#3d3015', h2: '#2e1f3d', border: 'rgba(251,191,36,0.3)' },  // gold
    { h1: '#1a2d4a', h2: '#2e1f3d', border: 'rgba(96,165,250,0.3)' },  // blue
    { h1: '#2d1f4a', h2: '#2e1f3d', border: 'rgba(167,139,250,0.3)' }, // purple
    { h1: '#1a3a2a', h2: '#2e1f3d', border: 'rgba(74,222,128,0.3)' },  // green
    { h1: '#4a2a1a', h2: '#2e1f3d', border: 'rgba(251,146,60,0.3)' },  // orange
    { h1: '#1a3a3a', h2: '#2e1f3d', border: 'rgba(94,234,212,0.3)' },  // teal
    { h1: '#3a1a2a', h2: '#2e1f3d', border: 'rgba(244,63,94,0.3)' },   // rose
  ];
  const p = palette[cardIndex % palette.length];
  const front = document.querySelector('.flashcard-front');
  front.style.setProperty('--card-bg', `linear-gradient(160deg, ${p.h1}, ${p.h2})`);
  front.style.setProperty('--card-border', p.border);

  $('#card-word').textContent = card.word;
  $('#card-level').textContent = card.level;
  $('#card-level').className = 'card-level-badge ' + levelClass(card.level);

  // Back ‚Äî sentence with each word wrapped for highlight animation
  const sentenceWords = card.sentence.match(/\S+/g) || [];
  const sentenceHtml = sentenceWords.map((w, i) => {
    const clean = cleanWord(w);
    const cls = clean === card.word ? 'word-span highlight' : 'word-span';
    return `<span class="${cls}" data-word-idx="${i}">${escapeHtml(w)}</span>`;
  }).join(' ');
  $('#card-sentence').innerHTML = sentenceHtml;
  $('#card-image').src = card.imageDataUrl || currentDeck.imageDataUrl;

  // Counter
  $('#card-counter').textContent = `${cardIndex + 1} / ${currentDeck.cards.length}`;

  // Know button state
  const knowBtn = $('#know-btn');
  if (card.learned) {
    knowBtn.textContent = 'Learned! ‚òÖ';
    knowBtn.classList.add('known');
  } else {
    knowBtn.textContent = 'I Know This! ‚úì';
    knowBtn.classList.remove('known');
  }

  renderCardDots();
}

function renderCardDots() {
  $('#card-dots').innerHTML = currentDeck.cards.map((card, i) => {
    let cls = 'card-dot';
    if (i === cardIndex) cls += ' active';
    if (card.learned) cls += ' learned';
    return `<div class="${cls}"></div>`;
  }).join('');
}

function flipCard() {
  $('#flashcard').classList.toggle('flipped');
}

function nextCard() {
  if (!currentDeck || cardIndex >= currentDeck.cards.length - 1) return;
  const fc = $('#flashcard');
  fc.classList.add('swipe-left');
  fc.addEventListener('animationend', function handler() {
    fc.classList.remove('swipe-left');
    fc.removeEventListener('animationend', handler);
  });
  cardIndex++;
  // Render at the invisible midpoint (35% of 500ms)
  setTimeout(() => renderFlashcard(), 180);
}

function prevCard() {
  if (!currentDeck || cardIndex <= 0) return;
  const fc = $('#flashcard');
  fc.classList.add('swipe-right');
  fc.addEventListener('animationend', function handler() {
    fc.classList.remove('swipe-right');
    fc.removeEventListener('animationend', handler);
  });
  cardIndex--;
  setTimeout(() => renderFlashcard(), 180);
}

function markAsKnown() {
  if (!currentDeck) return;
  const card = currentDeck.cards[cardIndex];

  if (card.learned) {
    card.learned = false;
    removeLearnedWord(card.word);
  } else {
    card.learned = true;
    addLearnedWord(card.word);
    celebrate();
  }

  renderFlashcard();

  if (currentDeck.id) {
    saveDeckToDB(currentDeck);
  }
}

// ===== TTS =====
const audioCache = new Map(); // In-memory cache for decoded AudioBuffers

async function loadAudioFromDB(word) {
  try {
    const db = await openDB();
    return new Promise((resolve) => {
      const tx = db.transaction('audio', 'readonly');
      const req = tx.objectStore('audio').get(word);
      req.onsuccess = () => resolve(req.result?.data || null);
      req.onerror = () => resolve(null);
    });
  } catch(e) { return null; }
}

async function saveAudioToDB(word, arrayBuffer) {
  try {
    const db = await openDB();
    const tx = db.transaction('audio', 'readwrite');
    tx.objectStore('audio').put({ word, data: arrayBuffer });
  } catch(e) { /* non-critical */ }
}

async function speakWord(word) {
  stopCurrentAudio();
  await ensureAudioContext();

  const speakBtn = $('#card-speak');
  if (speakBtn) speakBtn.classList.add('loading');

  try {
    let audioBuffer;
    const cacheKey = word.toLowerCase();

    // 1. Check in-memory cache (instant)
    if (audioCache.has(cacheKey)) {
      audioBuffer = audioCache.get(cacheKey);
    } else {
      // 2. Check IndexedDB (persistent across sessions)
      const savedData = await loadAudioFromDB(cacheKey);
      if (savedData) {
        audioBuffer = await audioCtx.decodeAudioData(savedData.slice(0));
        audioCache.set(cacheKey, audioBuffer);
      } else {
        // 3. Fetch from OpenAI TTS
        const voice = localStorage.getItem('voice') || 'fable';
        const speed = 0.7;

        const response = await fetch('https://api.openai.com/v1/audio/speech', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: 'tts-1',
            input: word,
            voice: voice,
            speed: speed,
            response_format: 'mp3'
          })
        });

        if (!response.ok) throw new Error('TTS error');

        const arrayBuffer = await response.arrayBuffer();
        // Save raw mp3 to IndexedDB for permanent storage
        await saveAudioToDB(cacheKey, arrayBuffer.slice(0));
        audioBuffer = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
        audioCache.set(cacheKey, audioBuffer);
      }
    }

    const source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioCtx.destination);
    currentAudioSource = source;
    source.onended = () => { currentAudioSource = null; };
    source.start(0);
  } catch(e) {
    console.error('TTS failed:', e);
  } finally {
    if (speakBtn) speakBtn.classList.remove('loading');
  }
}

let wordHighlightTimers = [];

function clearWordHighlights() {
  wordHighlightTimers.forEach(t => clearTimeout(t));
  wordHighlightTimers = [];
  document.querySelectorAll('#card-sentence .word-span.speaking').forEach(el => {
    el.classList.remove('speaking');
  });
}

async function speakSentence(sentence) {
  stopCurrentAudio();
  clearWordHighlights();
  await ensureAudioContext();

  const btn = $('#card-sentence-speak');
  if (btn) btn.classList.add('loading');

  try {
    const voice = localStorage.getItem('voice') || 'fable';
    const speed = parseFloat(localStorage.getItem('speed') || '0.9');

    const response = await fetch('https://api.openai.com/v1/audio/speech', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: 'tts-1',
        input: sentence,
        voice: voice,
        speed: speed,
        response_format: 'mp3'
      })
    });

    if (!response.ok) throw new Error('TTS error');

    const arrayBuffer = await response.arrayBuffer();
    const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer.slice(0));

    const source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioCtx.destination);
    currentAudioSource = source;
    source.onended = () => {
      currentAudioSource = null;
      clearWordHighlights();
    };
    source.start(0);

    // Animate word-by-word highlight based on estimated timing
    const wordSpans = document.querySelectorAll('#card-sentence .word-span');
    if (wordSpans.length > 0) {
      const duration = audioBuffer.duration * 1000; // ms
      // Weight timing by word length (longer words take longer to speak)
      const words = [];
      let totalLen = 0;
      wordSpans.forEach(span => {
        const len = Math.max(span.textContent.length, 1);
        words.push({ span, len });
        totalLen += len;
      });

      let elapsed = 0;
      // Small initial delay for TTS startup
      const startDelay = 80;
      words.forEach((w, i) => {
        const wordDuration = (w.len / totalLen) * (duration - startDelay);
        const startTime = startDelay + elapsed;
        elapsed += wordDuration;

        const timer = setTimeout(() => {
          // Remove previous highlights
          wordSpans.forEach(s => s.classList.remove('speaking'));
          w.span.classList.add('speaking');
        }, startTime);
        wordHighlightTimers.push(timer);
      });
    }
  } catch(e) {
    console.error('Sentence TTS failed:', e);
  } finally {
    if (btn) btn.classList.remove('loading');
  }
}

// ===== SWIPE & TAP GESTURES =====
let touchStartX = 0;
let touchStartY = 0;
let didSwipe = false;

const flashcardArea = $('#flashcard-area');

flashcardArea.addEventListener('touchstart', (e) => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
  didSwipe = false;
}, { passive: true });

flashcardArea.addEventListener('touchend', (e) => {
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;

  if (Math.abs(dx) > 60 && Math.abs(dx) > Math.abs(dy) + 10) {
    didSwipe = true;
    if (dx < 0) nextCard();
    else prevCard();
  }
}, { passive: true });

// Flip card on click (guarded against swipe and speaker buttons)
$('#flashcard').addEventListener('click', (e) => {
  if (didSwipe) { didSwipe = false; return; }
  if (e.target.closest('#card-speak') || e.target.closest('#card-sentence-speak')) return;
  flipCard();
});

// ===== INDEXEDDB =====
const DB_NAME = 'FlashcardDB';
const DB_VERSION = 2;

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains('decks')) {
        db.createObjectStore('decks', { keyPath: 'id' });
      }
      if (!db.objectStoreNames.contains('audio')) {
        db.createObjectStore('audio', { keyPath: 'word' });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function saveDeckToDB(deck) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction('decks', 'readwrite');
    tx.objectStore('decks').put(deck);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

async function loadDecksFromDB() {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction('decks', 'readonly');
    const req = tx.objectStore('decks').getAll();
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function deleteDeckFromDB(deckId) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction('decks', 'readwrite');
    tx.objectStore('decks').delete(deckId);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

// ===== CREATE DECK =====
async function createFlashcardDeck() {
  const activeCards = pendingCards.filter(c => !excludedWords.has(c.word));
  if (activeCards.length === 0) return;

  const firstSentence = pendingSentences[0] || 'Untitled';
  const name = firstSentence.length > 40
    ? firstSentence.substring(0, 37) + '...'
    : firstSentence;

  const deck = {
    id: 'deck-' + Date.now(),
    name: name,
    createdAt: new Date().toISOString(),
    imageDataUrl: pendingImageDataUrl,
    sentences: pendingSentences,
    cards: activeCards.map(c => ({ word: c.word, sentence: c.sentence, level: c.level, learned: c.learned }))
  };

  try {
    await saveDeckToDB(deck);
    closeTextReview();
    closeCamera();
    await renderLibrary();
    openFlashcardView(deck);
  } catch (err) {
    console.error('Failed to save deck:', err);
  }
}

// ===== DECK LIBRARY (HOME) =====
async function renderLibrary() {
  let decks = [];
  try { decks = await loadDecksFromDB(); } catch(e) { console.error(e); }

  const grid = $('#library-grid');
  const studyBar = $('#study-all-bar');
  const manageBar = $('#manage-decks-bar');

  if (decks.length === 0) {
    studyBar.style.display = 'none';
    manageBar.style.display = 'none';
    grid.innerHTML = `
      <div class="library-empty">
        <span class="empty-icon">üÉè</span>
        No flashcard decks yet!<br>Capture a book page to create one.
      </div>`;
    return;
  }

  // Collect all unique words across all decks
  const learned = getLearnedWords();
  const wordMap = new Map(); // word -> { word, sentence, level, imageDataUrl }
  for (const deck of decks) {
    for (const card of deck.cards) {
      if (!wordMap.has(card.word)) {
        wordMap.set(card.word, {
          word: card.word,
          sentence: card.sentence,
          level: card.level,
          imageDataUrl: deck.imageDataUrl
        });
      }
    }
  }

  const allWordsList = [...wordMap.values()];
  const levelOrder = ['Pre-Primer', 'Primer', 'First Grade', 'Second Grade', 'Third Grade'];
  allWordsList.sort((a, b) => levelOrder.indexOf(a.level) - levelOrder.indexOf(b.level));

  const totalWords = allWordsList.length;
  const totalLearned = allWordsList.filter(w => learned.has(w.word)).length;

  studyBar.style.display = 'flex';
  manageBar.style.display = 'flex';
  $('#study-all-count').textContent = `${totalLearned}/${totalWords} learned`;

  // Store for click handler
  window._homeWordList = allWordsList;

  const cardColors = ['#ec4899','#fbbf24','#60a5fa','#a78bfa','#4ade80','#fb923c','#5eead4','#f43f5e'];

  grid.innerHTML = allWordsList.map((w, i) => {
    const bg = cardColors[i % cardColors.length];
    const isLearned = learned.has(w.word);
    return `
      <div class="word-card${isLearned ? ' learned' : ''}" data-word-idx="${i}" style="border-color:${bg}; background: linear-gradient(135deg, ${bg}22, ${bg}11);">
        <div class="word-card-word" style="color:${bg}">${escapeHtml(w.word)}</div>
        <div class="word-card-level" style="color:${bg}">${w.level}</div>
      </div>`;
  }).join('');
}

async function studyAllWords() {
  let decks = [];
  try { decks = await loadDecksFromDB(); } catch(e) { return; }
  if (decks.length === 0) return;

  // Merge all cards, deduplicate by word (keep first occurrence for sentence/image)
  const seen = new Set();
  const learned = getLearnedWords();
  const allCards = [];

  for (const deck of decks) {
    for (const card of deck.cards) {
      if (!seen.has(card.word)) {
        seen.add(card.word);
        allCards.push({
          word: card.word,
          sentence: card.sentence,
          level: card.level,
          learned: learned.has(card.word),
          imageDataUrl: deck.imageDataUrl
        });
      }
    }
  }

  // Sort by difficulty
  const levelOrder = ['Pre-Primer', 'Primer', 'First Grade', 'Second Grade', 'Third Grade'];
  allCards.sort((a, b) => levelOrder.indexOf(a.level) - levelOrder.indexOf(b.level));

  // Create a virtual deck (not saved ‚Äî it's a combined view)
  const combinedDeck = {
    id: null, // null = don't persist
    name: 'All Words',
    imageDataUrl: decks[0].imageDataUrl,
    cards: allCards,
    _isComposite: true
  };

  openFlashcardView(combinedDeck);
}

$('#library-grid').addEventListener('click', async (e) => {
  const wordCard = e.target.closest('.word-card');
  if (wordCard && window._homeWordList) {
    const idx = parseInt(wordCard.dataset.wordIdx, 10);
    const learned = getLearnedWords();
    const allCards = window._homeWordList.map(w => ({
      word: w.word,
      sentence: w.sentence,
      level: w.level,
      learned: learned.has(w.word),
      imageDataUrl: w.imageDataUrl
    }));
    const combinedDeck = {
      id: null,
      name: 'All Words',
      imageDataUrl: allCards[0]?.imageDataUrl,
      cards: allCards,
      _isComposite: true
    };
    openFlashcardView(combinedDeck, idx);
  }
});

// Manage Decks modal
$('#manage-decks-btn').addEventListener('click', async () => {
  let decks = [];
  try { decks = await loadDecksFromDB(); } catch(e) { return; }
  if (decks.length === 0) return;

  const deckNames = decks.map((d, i) => `${i + 1}. ${d.name} (${d.cards.length} words)`).join('\n');
  const input = prompt('Enter deck number to delete:\n\n' + deckNames);
  if (!input) return;
  const num = parseInt(input, 10);
  if (num >= 1 && num <= decks.length) {
    if (confirm(`Delete "${decks[num - 1].name}"?`)) {
      await deleteDeckFromDB(decks[num - 1].id);
      await renderLibrary();
    }
  }
});

// ===== PROGRESS PANEL =====
function openProgress() {
  renderProgress();
  $('#progress-panel').classList.add('visible');
}

function closeProgress() {
  $('#progress-panel').classList.remove('visible');
}

function renderProgress() {
  const learned = getLearnedWords();
  const learnedCount = [...learned].filter(w => DOLCH_SET.has(w)).length;

  const levelColors = {
    'Pre-Primer': 'var(--pink)',
    'Primer': 'var(--yellow)',
    'First Grade': 'var(--blue)',
    'Second Grade': 'var(--purple)',
    'Third Grade': 'var(--green)'
  };

  let html = `
    <div class="progress-overall">
      <div class="progress-big-number">${learnedCount} / 220</div>
      <div class="progress-subtitle">Dolch sight words learned</div>
    </div>`;

  const levelOrder = ['Pre-Primer', 'Primer', 'First Grade', 'Second Grade', 'Third Grade'];

  for (const level of levelOrder) {
    const words = DOLCH_LEVELS[level];
    const levelLearned = words.filter(w => learned.has(w));
    const pct = Math.round((levelLearned.length / words.length) * 100);
    const color = levelColors[level];

    html += `
      <div class="level-section">
        <div class="level-header">
          <span class="level-name" style="color: ${color}">${level}</span>
          <span class="level-count">${levelLearned.length} / ${words.length}</span>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" style="width: ${pct}%; background: ${color}"></div>
        </div>
        <div class="level-words">
          ${words.map(w =>
            `<span class="word-chip${learned.has(w) ? ' learned' : ''}" data-word="${w}">${w}</span>`
          ).join('')}
        </div>
      </div>`;
  }

  $('#progress-content').innerHTML = html;
}

$('#progress-content').addEventListener('click', (e) => {
  const chip = e.target.closest('.word-chip');
  if (chip) speakWord(chip.dataset.word);
});

// ===== CELEBRATION =====
function celebrate() {
  const container = $('#celebration');
  const colors = ['#f472b6', '#fbbf24', '#60a5fa', '#a78bfa', '#4ade80', '#fb923c'];

  for (let i = 0; i < 30; i++) {
    const confetti = document.createElement('div');
    confetti.className = 'confetti';
    confetti.style.left = Math.random() * 100 + 'vw';
    confetti.style.top = Math.random() * 40 + 'vh';
    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
    confetti.style.animationDelay = Math.random() * 0.3 + 's';
    confetti.style.width = (6 + Math.random() * 8) + 'px';
    confetti.style.height = (6 + Math.random() * 8) + 'px';
    container.appendChild(confetti);
  }

  setTimeout(() => { container.innerHTML = ''; }, 1500);
}

// ===== EVENT LISTENERS =====
$('#camera-fab').addEventListener('click', openCamera);
$('#close-camera').addEventListener('click', closeCamera);
$('#capture-btn').addEventListener('click', processPage);
$('#progress-btn').addEventListener('click', openProgress);
$('#close-progress').addEventListener('click', closeProgress);
$('#close-review').addEventListener('click', closeTextReview);
$('#make-flashcards-btn').addEventListener('click', createFlashcardDeck);
$('#close-flashcards').addEventListener('click', () => {
  closeFlashcardView();
  renderLibrary();
});
$('#study-all-btn').addEventListener('click', studyAllWords);

$('#card-speak').addEventListener('click', (e) => {
  e.stopPropagation();
  if (currentDeck) speakWord(currentDeck.cards[cardIndex].word);
});

$('#card-sentence-speak').addEventListener('click', (e) => {
  e.stopPropagation();
  if (currentDeck) speakSentence(currentDeck.cards[cardIndex].sentence);
});

$('#know-btn').addEventListener('click', markAsKnown);

// Settings
$('#settings-btn').addEventListener('click', () => {
  $('#settings-api-key').value = apiKey;
  $('#voice').value = localStorage.getItem('voice') || 'fable';
  $('#speed').value = localStorage.getItem('speed') || '0.9';
  $('#settings-panel').classList.add('visible');
});

$('#close-settings').addEventListener('click', () => {
  $('#settings-panel').classList.remove('visible');
});

$('#save-settings').addEventListener('click', () => {
  const newKey = $('#settings-api-key').value.trim();
  if (newKey) {
    apiKey = newKey;
    localStorage.setItem('openai_api_key', apiKey);
  }
  localStorage.setItem('voice', $('#voice').value);
  localStorage.setItem('speed', $('#speed').value);
  $('#settings-panel').classList.remove('visible');
});

// API key overlay
$('#submit-api-key').addEventListener('click', async () => {
  const key = $('#initial-api-key').value.trim();
  if (!key) return;
  await ensureAudioContext();
  apiKey = key;
  localStorage.setItem('openai_api_key', apiKey);
  $('#api-key-overlay').classList.add('hidden');
});

$('#initial-api-key').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') $('#submit-api-key').click();
});

// ===== INIT =====
async function init() {
  if (apiKey) {
    $('#api-key-overlay').classList.add('hidden');
  }
  await renderLibrary();
}

init();
</script>
</body>
</html>
